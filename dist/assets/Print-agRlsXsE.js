import{r as te,ah as oe,d as ne,j as re}from"./index-CwdxULia.js";var _={exports:{}};(function(U,se){(function(O,F){U.exports=F(te)})(typeof self<"u"?self:oe,function(O){return function(){var F={155:function(e){e.exports=O}},q={};function A(e){var t=q[e];if(t!==void 0)return t.exports;var n=q[e]={exports:{}};return F[e](n,n.exports,A),n.exports}A.d=function(e,t){for(var n in t)A.o(t,n)&&!A.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},A.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},A.r=function(e){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var H={};A.r(H),A.d(H,{useReactToPrint:function(){return X}});var J=A(155);function d({level:e="error",messages:t,suppressErrors:n=!1}){n||(e==="error"?console.error(t):e==="warning"?console.warn(t):e==="debug"&&console.debug(t))}function L(e,t){if(t||!e){const n=document.getElementById("printWindow");n&&document.body.removeChild(n)}}function $(e,t){const{documentTitle:n,onAfterPrint:l,onPrintError:m,preserveAfterPrint:u,print:E,suppressErrors:p}=t;setTimeout(()=>{var b,v;if(e.contentWindow)if(e.contentWindow.focus(),E)E(e).then(()=>l==null?void 0:l()).then(()=>L(u)).catch(y=>{m?m("print",y):d({messages:["An error was thrown by the specified `print` function"],suppressErrors:p})});else{if(e.contentWindow.print){const y=(v=(b=e.contentDocument)===null||b===void 0?void 0:b.title)!==null&&v!==void 0?v:"",k=e.ownerDocument.title;n&&(e.ownerDocument.title=n,e.contentDocument&&(e.contentDocument.title=n)),e.contentWindow.print(),n&&(e.ownerDocument.title=k,e.contentDocument&&(e.contentDocument.title=y))}else d({messages:["Printing for this browser is not currently possible: the browser does not have a `print` method available for iframes."],suppressErrors:p});l==null||l(),L(u)}else d({messages:["Printing failed because the `contentWindow` of the print iframe did not load. This is possibly an error with `react-to-print`. Please file an issue: https://github.com/MatthewHerbst/react-to-print/issues/"],suppressErrors:p})},500)}function B(e){const t=[],n=document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null);let l=n.nextNode();for(;l;)t.push(l),l=n.nextNode();return t}function z(e,t,n){const l=B(e),m=B(t);if(l.length===m.length)for(let u=0;u<l.length;u++){const E=l[u],p=m[u],b=E.shadowRoot;if(b!==null){const v=p.attachShadow({mode:b.mode});v.innerHTML=b.innerHTML,z(b,v,n)}}else d({messages:["When cloning shadow root content, source and target elements have different size. `onBeforePrint` likely resolved too early.",e,t],suppressErrors:n})}const K=`
    @page {
        /* Remove browser default header (title) and footer (url) */
        margin: 0;
    }
    @media print {
        body {
            /* Tell browsers to print background colors */
            color-adjust: exact; /* Firefox. This is an older version of "print-color-adjust" */
            print-color-adjust: exact; /* Firefox/Safari */
            -webkit-print-color-adjust: exact; /* Chrome/Safari/Edge/Opera */
        }
    }
`;function Q(e,t,n,l){var m,u,E;const{contentNode:p,clonedContentNode:b,clonedImgNodes:v,clonedVideoNodes:y,numResourcesToLoad:k,originalCanvasNodes:j}=n,{bodyClass:C,fonts:N,ignoreGlobalStyles:I,pageStyle:R,nonce:w,suppressErrors:P,copyShadowRoots:W}=l;e.onload=null;const a=e.contentDocument||((m=e.contentWindow)===null||m===void 0?void 0:m.document);if(a){const D=a.body.appendChild(b);W&&z(p,D,!!P),N&&(!((u=e.contentDocument)===null||u===void 0)&&u.fonts&&(!((E=e.contentWindow)===null||E===void 0)&&E.FontFace)?N.forEach(r=>{const o=new FontFace(r.family,r.source,{weight:r.weight,style:r.style});e.contentDocument.fonts.add(o),o.loaded.then(()=>{t(o)}).catch(h=>{t(o,["Failed loading the font:",o,"Load error:",h])})}):(N.forEach(r=>t(r)),d({messages:['"react-to-print" is not able to load custom fonts because the browser does not support the FontFace API but will continue attempting to print the page'],suppressErrors:P})));const i=R??K,x=a.createElement("style");w&&(x.setAttribute("nonce",w),a.head.setAttribute("nonce",w)),x.appendChild(a.createTextNode(i)),a.head.appendChild(x),C&&a.body.classList.add(...C.split(" "));const M=a.querySelectorAll("canvas");for(let r=0;r<j.length;++r){const o=j[r],h=M[r];if(h===void 0){d({messages:["A canvas element could not be copied for printing, has it loaded? `onBeforePrint` likely resolved too early.",o],suppressErrors:P});continue}const s=h.getContext("2d");s&&s.drawImage(o,0,0)}for(let r=0;r<v.length;r++){const o=v[r],h=o.getAttribute("src");if(h){const s=new Image;s.onload=()=>t(o),s.onerror=(c,f,S,g,T)=>t(o,["Error loading <img>",o,"Error",T]),s.src=h}else t(o,['Found an <img> tag with an empty "src" attribute. This prevents pre-loading it.',o])}for(let r=0;r<y.length;r++){const o=y[r];o.preload="auto";const h=o.getAttribute("poster");if(h){const s=new Image;s.onload=()=>t(o),s.onerror=(c,f,S,g,T)=>t(o,["Error loading video poster",h,"for video",o,"Error:",T]),s.src=h}else o.readyState>=2?t(o):(o.onloadeddata=()=>t(o),o.onerror=(s,c,f,S,g)=>t(o,["Error loading video",o,"Error",g]),o.onstalled=()=>t(o,["Loading video stalled, skipping",o]))}const V="select",Y=p.querySelectorAll(V),Z=a.querySelectorAll(V);for(let r=0;r<Y.length;r++)Z[r].value=Y[r].value;if(!I){const r=document.querySelectorAll("style, link[rel~='stylesheet'], link[as='style']");for(let o=0,h=r.length;o<h;++o){const s=r[o];if(s.tagName.toLowerCase()==="style"){const c=a.createElement(s.tagName),f=s.sheet;if(f){let S="";try{const g=f.cssRules.length;for(let T=0;T<g;++T)typeof f.cssRules[T].cssText=="string"&&(S+=`${f.cssRules[T].cssText}\r
`)}catch(g){d({messages:["A stylesheet could not be accessed. This is likely due to the stylesheet having cross-origin imports, and many browsers block script access to cross-origin stylesheets. See https://github.com/MatthewHerbst/react-to-print/issues/429 for details. You may be able to load the sheet by both marking the stylesheet with the cross `crossorigin` attribute, and setting the `Access-Control-Allow-Origin` header on the server serving the stylesheet. Alternatively, host the stylesheet on your domain to avoid this issue entirely.",s,`Original error: ${g==null?void 0:g.message}`],level:"warning"})}c.setAttribute("id",`react-to-print-${o}`),w&&c.setAttribute("nonce",w),c.appendChild(a.createTextNode(S)),a.head.appendChild(c)}}else if(s.getAttribute("href"))if(s.hasAttribute("disabled"))d({messages:["`react-to-print` encountered a <link> tag with a `disabled` attribute and will ignore it. Note that the `disabled` attribute is deprecated, and some browsers ignore it. You should stop using it. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-disabled. The <link> is:",s],level:"warning"}),t(s);else{const c=a.createElement(s.tagName);for(let f=0,S=s.attributes.length;f<S;++f){const g=s.attributes[f];g&&c.setAttribute(g.nodeName,g.nodeValue||"")}c.onload=()=>t(c),c.onerror=(f,S,g,T,ee)=>t(c,["Failed to load",c,"Error:",ee]),w&&c.setAttribute("nonce",w),a.head.appendChild(c)}else d({messages:["`react-to-print` encountered a <link> tag with an empty `href` attribute. In addition to being invalid HTML, this can cause problems in many browsers, and so the <link> was not loaded. The <link> is:",s],level:"warning"}),t(s)}}}k===0&&$(e,l)}function G(e,t,n,l){e.onload=()=>Q(e,t,n,l),document.body.appendChild(e)}function X(e){const{contentRef:t,fonts:n,ignoreGlobalStyles:l,onBeforePrint:m,onPrintError:u,preserveAfterPrint:E,suppressErrors:p}=e;return(0,J.useCallback)(v=>{L(E,!0);const y=function({contentRef:i,optionalContent:x,suppressErrors:M}){return x&&(i&&d({level:"warning",messages:['"react-to-print" received a `contentRef` option and a optional-content param passed to its callback. The `contentRef` option will be ignored.']}),typeof x=="function")?x():i?i.current:void d({messages:['"react-to-print" did not receive a `contentRef` option or a optional-content param pass to its callback.'],suppressErrors:M})}({contentRef:t,optionalContent:v,suppressErrors:p});if(!y)return void d({messages:["There is nothing to print"],suppressErrors:p});const k=y.cloneNode(!0),j=document.querySelectorAll("link[rel~='stylesheet'], link[as='style']"),C=k.querySelectorAll("img"),N=k.querySelectorAll("video"),I=n?n.length:0,R=(l?0:j.length)+C.length+N.length+I,w=[],P=[],W=function(){const i=document.createElement("iframe");return i.width=`${document.documentElement.clientWidth}px`,i.height=`${document.documentElement.clientHeight}px`,i.style.position="absolute",i.style.top=`-${document.documentElement.clientHeight+100}px`,i.style.left=`-${document.documentElement.clientWidth+100}px`,i.id="printWindow",i.srcdoc="<!DOCTYPE html>",i}(),a=(i,x)=>{w.includes(i)?d({level:"debug",messages:["Tried to mark a resource that has already been handled",i],suppressErrors:p}):(x?(d({messages:['"react-to-print" was unable to load a resource but will continue attempting to print the page',...x],suppressErrors:p}),P.push(i)):w.push(i),w.length+P.length===R&&$(W,e))},D={contentNode:y,clonedContentNode:k,clonedImgNodes:C,clonedVideoNodes:N,numResourcesToLoad:R,originalCanvasNodes:y.querySelectorAll("canvas")};m?m().then(()=>G(W,a,D,e)).catch(i=>{u==null||u("onBeforePrint",i)}):G(W,a,D,e)},[e])}return H}()})})(_);var le=_.exports;const ae=ne(re.jsx("path",{d:"M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3m-3 11H8v-5h8zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1m-1-9H6v4h12z"}),"Print");export{ae as P,le as l};
